name: Node.js CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x] # Use Node.js 20

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies (quiet)
      run: npm ci --silent

    - name: Run ESLint (quiet, save full log)
      run: |
        mkdir -p ci-logs
        npm run lint --silent 2>&1 | tee ci-logs/lint.log || true
        echo "---- lint log (truncated) ----"
        head -n 200 ci-logs/lint.log || true

    - name: Run Unit Tests (quiet, save full log)
      run: |
        mkdir -p ci-logs
        npm test --silent 2>&1 | tee ci-logs/test.log || true
        echo "---- test log (truncated) ----"
        head -n 300 ci-logs/test.log || true

    # === Example: Safe AI/content-generation step with fallback for content-filtering ===
    # Replace the command below with your actual AI action/CLI. The pattern:
    #  - captures full stdout/stderr to files in ci-logs
    #  - inspects stderr for content-filter indicators
    #  - sets an output `ai_status` via GITHUB_OUTPUT:
    #      - 'success'  -> AI completed successfully
    #      - 'blocked'  -> AI was blocked by content filters (job will NOT fail)
    #      - 'error'    -> non-filter error (defaults to failing the step)
    - name: Run AI content-generation (safe wrapper)
      id: ai_step
      env:
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        mkdir -p ci-logs
        set -o pipefail

        # Example AI command - replace with your real CLI or script.
        # stdout -> ci-logs/ai-output.json, stderr -> ci-logs/ai.err
        ai-cli generate --input input.json > ci-logs/ai-output.json 2> ci-logs/ai.err || true
        # Inspect stderr for common content-filtering phrases
        if grep -Ei "content filter|blocked by|content blocked|policy|forbidden|abuse|rate limit" ci-logs/ai.err >/dev/null 2>&1; then
          echo "AI step appears to be blocked by content filtering. Saving diagnostics."
          echo "ai_status=blocked" >> $GITHUB_OUTPUT
          # Provide a short console summary to avoid massive logs
          echo "---- ai.err (truncated) ----"
          head -n 80 ci-logs/ai.err || true
          # exit 0 to avoid failing the entire job
          exit 0
        fi

        # If the command exited non-zero for other reasons, mark as error (fail step)
        if [ -s ci-logs/ai.err ]; then
          echo "AI step failed for reasons other than content filtering."
          echo "ai_status=error" >> $GITHUB_OUTPUT
          echo "---- ai.err (truncated) ----"
          head -n 120 ci-logs/ai.err || true
          # Non-filtering errors should fail the job so they get attention
          exit 1
        fi

        # Otherwise, success
        echo "ai_status=success" >> $GITHUB_OUTPUT
        echo "AI step completed successfully."
      continue-on-error: false

    - name: Handle AI fallback downstream (example)
      if: steps.ai_step.outputs.ai_status == 'blocked'
      run: |
        echo "AI was blocked by content filters. Skipping dependent work that uses AI output."
        # Optionally create a small placeholder artifact so downstream jobs have something to work with
        mkdir -p ci-logs
        echo "{}" > ci-logs/ai-output-placeholder.json

    # Always upload logs/artifacts so you can inspect them after the run
    - name: Upload CI logs and AI diagnostics
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ci-logs
        path: ci-logs
